/**
   Custom Task
   -----------
   A simple custom Task that runs and reports progress.
   Usually lives inside a "CJob" object, which manages a series of CTasks
   
   Some Notes:
	- You can only `throw (string)` from the main body of the task
	  else you can call t.fail(error) to pass up the error to the Job
   
	- Tasks with INFO starting with '-' will have PROGRESS EMIT disabled
	- A function that is executed and handled by a CJOB object
	- Extend and override start() 
	- Populate the `quickrun` object to quickly create a Task without extending
	
**/
   
package djNode.task;
import djNode.tools.HTool;
import djNode.tools.LOG;
import djNode.utils.ISendingProgress;
import haxe.Timer;

enum CTaskStatus
{
	waiting; complete; start; fail; progress; forcekill;
}


@:allow(djNode.task.CJob)
class CTask 
{
	// UID generator
	static var UID:Int = 0;
	
	// Task Unique ID, Autogenerated if not set
	public var uid(default, null):Int;
	
	// General info text for this task, 
	// e.g. "downloading file http://test.one/file.zip"
	public var info(default, null):String;
	
	// Current Progress 0-100
	public var PROGRESS(default, set):Int;	
		function set_PROGRESS(value){
			PROGRESS = value; 
			if (PROGRESS < 0) PROGRESS = 0; else if(PROGRESS>100) PROGRESS = 100;
			if (!FLAG_PROGRESS_DISABLE) onStatus(CTaskStatus.progress, this);
			return value;
		}// -
	
	// If true will not report progress or count towards job progress
	// Useful for small tasks that start and end instantaneously
	public var FLAG_PROGRESS_DISABLE:Bool = false;
	
	// Current lifecycle step
	// DEV: Setting this will callcack to JOB and USER (from JOB event listener)
	public var status(default, set):CTaskStatus;
		function set_status(val){
			status = val;
			onStatus(val, this);
			return val;
		}
		
	// JOB parallel execution Slot Index for this task
	public var SLOT(default, null):Int;
	
	// # Extra call when this task is completed
	// - Normally task progress will report to JOB and USER with the event system
	// - This is available if you want to do something after a specific task is complete 
	// - Clean Stack
	public var onComplete:Void->Void;
	
	// # Extra call when this task fails
	// - Clean Stack
	public var onFail:Void->Void;
	
	// # Handled by parent Job
	// Available statuses ==
	//		start	:	The task has just started
	//		progress:	The task progress has changed
	//		complete:	The task has been completed
	//		fail	:	The task has failed, read the ERROR field
	var onStatus:CTaskStatus->CTask->Void = function(a, b){};
	
	// # USER SET
	// if you want to declare a kill function on quick tasks, here is where you do it
	public var killExtra:Void->Void = null;
	
	// # USER SET
	// Called automatically when a JOB fails and the task needs to be force killed
	public var killForce:Void->Void = null;
	
	// Pointer to the Job holding this task
	public var parent(default, null):CJob;
	
	// CJob sets this
	// SYNC tasks run by themselves while no other task is running on the Job
	// ASYNC tasks can run in parallel with other ASYNC tasks on the Job
	var async:Bool = false;

	// -- Data
	// Pointer to JOB's shared data object
	@:isVar
	public var jobData(get, set):Dynamic;
		function get_jobData(){
			return parent.jobData;
		}
		function set_jobData(val){
			return jobData = val;
		}
		
	// Data read from the previous task
	var dataGet:Dynamic;

	// Data to send to the next task
	var dataSend:Dynamic;

	// Data that is unique to the task, perhaps you might need this sometimes
	public var custom:Dynamic;

	// If set, then this code will run at task start
	var quickRun:CTask->Void;
	// --
	
	var timeStart:Float;
	
	// In case of error, READ THIS 
	public var ERROR:String;
	
	//====================================================;
	
	// -
	public function new(?Info:String, ?qRun:CTask->Void) 
	{
		uid = ++UID;
		info = Info;
		quickRun = qRun;
		
		status = CTaskStatus.waiting;
		
		if (info != null && info.charAt(0) == "-")
		{
			FLAG_PROGRESS_DISABLE = true;
			info = info.substr(1);
		}
		
	}//---------------------------------------------------;
	
	// # USER EXTEND
	// Or you can just use a quick_run
	public function start()
	{
		timeStart = Timer.stamp();
		status = CTaskStatus.start;
		PROGRESS = 0;
		if (quickRun != null) quickRun(this);
	}//---------------------------------------------------;
		
	// Can also be called from quickTasks
	// -
	public function complete()
	{
		if (status == CTaskStatus.forcekill) 
		{
			// Already handled, so do nothing.
			return;
		}
		
		PROGRESS = 100;
		status = CTaskStatus.complete;
		HTool.tCall(onComplete);
	}//---------------------------------------------------;

	// Can also be called from quickTasks
	// --
	public function fail(?message:String, ?pos:haxe.PosInfos)
	{
		if (status == CTaskStatus.forcekill) 
		{
			// Already handled, so do nothing.
			return;
		}
		
		ERROR = message;
		#if debug
		if (haxe.CallStack.exceptionStack().length == 0 && pos != null) {
			// DEV:  No log, JOB will log the TASK
			//		 Fail was manually called. Get line that it was called from
			ERROR += ' @ ' +  pos.fileName.split('/').pop() + ':' + pos.lineNumber;
		}
		#end
		
		status = CTaskStatus.fail;
		HTool.tCall(onFail);
	}//---------------------------------------------------;
	
	
	// # Called by parent Job
	// Automatically called whenever completed or failed
	// Useful to override and shutdown things gracefully
	function kill()
	{
		if (_killed) return;
			_killed = true;
		
		// The task was killed while it was running or waiting
		if (status != CTaskStatus.complete) {
			status = forcekill;
			HTool.sCall(killForce);
		}
		
		HTool.sCall(killExtra);
	}//---------------------------------------------------;
	var _killed(default,null):Bool = false;
	
	
	/**
	   Sync a progress object with this task
	   @return
	**/
	public function syncWith(p:ISendingProgress)
	{
		p.onComplete = complete;
		p.onFail = (f)->fail(f, null);
		p.onProgress = (p)-> PROGRESS = p;
	}//---------------------------------------------------;
	
	
	// Quick information
	// --
	public function toString():String
	{
		return (info == null?'':'[$info]') + ' uid_$uid slot_$SLOT' + (async?' (async)':'');
	}//---------------------------------------------------;
	
}// -