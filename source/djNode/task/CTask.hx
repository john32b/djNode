/**
   Custom Task
   -----------
   A simple custom Task that runs and reports progress.
   Usually lives inside a "CJob" object, which manages a series of CTasks
**/
   
package djNode.task;
import haxe.CallStack;


// Task Statuses
// Lifetime
enum CTaskStatus
{
	waiting; complete; start; fail; progress;
}



/**
   A Custom Task.
   - A function that is executed and handled by a CJOB object
   - Extend and override start() 
   - Populate the `quickrun` object to quickly create a Task without extending
**/
@:allow(djNode.task.CJob)
class CTask 
{
	// UID generator
	static var UID:Int = 0;
	
	// Task Unique ID, Autogenerated if not set
	public var uid(default, null):Int;
	
	// Short ID name of the task, e.g. "FileDownload"
	public var name(default, null):String;
	
	// Write something useful that will report to the User.
	// e.g. (Downloading file `0000425.jpg`)
	public var desc(default, null):String;
	
	// Current Progress 0-100
	public var PROGRESS(default, set):Int;	
		function set_PROGRESS(value){
			PROGRESS = value; 
			if (PROGRESS < 0) PROGRESS = 0; else if(PROGRESS>100) PROGRESS = 100;
			if (!FLAG_PROGRESS_DISABLE) onStatus(CTaskStatus.progress, this);
			return value;
		}// -
	
	// If true will not report progress or count towards job progress
	// Useful for small tasks that start and end instantaneously
	public var FLAG_PROGRESS_DISABLE:Bool = false;
	
	// Current lifecycle step
	public var status(default, set):CTaskStatus;
		function set_status(val){
			status = val;
			onStatus(val, this);
			return val;
		}
		
	// JOB parallel execution Slot Index for this task
	public var SLOT(default, null):Int;
	
	// #OPTIONAL #USERSET
	// Called when this task is completed
	var onComplete:Void->Void;
	
	// #USERSET  Called whenever the status changes
	// Available statuses ==
	//		start	:	The task has just started
	//		progress:	The task progress has changed
	//		complete:	The task has been completed
	//		fail	:	The task has failed, read the ERROR field
	var onStatus:CTaskStatus->CTask->Void = function(a, b){};
	
	// # USER SET
	// if you want to declare a kill function on quick tasks, here is where you do it
	public var killExtra:Void->Void = null;
	
	// Pointer to the Job holding this task
	var parent:CJob;
	
	// CJob sets this
	// SYNC tasks run by themselves while no other task is running on the Job
	// ASYNC tasks can run in parallel with other ASYNC tasks on the Job
	var async:Bool = false;

	// -- Data
	// Pointer to JOB's shared data object
	@:isVar
	public var jobData(get, set):Dynamic;
		function get_jobData(){
			return parent.jobData;
		}
		function set_jobData(val){
			return jobData = val;
		}
		
	// Data read from the previous task
	var dataGet:Dynamic;

	// Data to send to the next task
	var dataSend:Dynamic;

	// Data that is unique to the task, perhaps you might need this sometimes
	public var custom:Dynamic;

	// If set, then this code will run at task start
	var quickRun:CTask->Void;
	// --
	
	// In case of error, READ THIS 
	public var ERROR:String;
	
	//====================================================;
	
	// -
	public function new(?qRun:CTask->Void, ?Name:String, ?Desc:String) 
	{
		uid = ++UID;
		name = Name == null?'task_$uid':Name;
		desc = Desc;
		quickRun = qRun;
		
		status = CTaskStatus.waiting;
		
		if (name.charAt(0) == "-")
		{
			FLAG_PROGRESS_DISABLE = true;
			name = name.substr(1);
		}
		
	}//---------------------------------------------------;
	
	// # USER EXTEND
	// Or you can just use a quick_run
	public function start()
	{
		status = CTaskStatus.start;
		PROGRESS = 0;
		if (quickRun != null) quickRun(this);
	}//---------------------------------------------------;
		
	// Can also be called from quickTasks
	// -
	public function complete()
	{
		PROGRESS = 100;
		status = CTaskStatus.complete;
		if (onComplete != null) onComplete();
	}//---------------------------------------------------;

	// Can also be called from quickTasks
	// --
	public function fail(?message:String,?pos:haxe.PosInfos)
	{
		ERROR = message;
		
		// Fail was manually called.
		if (CallStack.exceptionStack().length == 0)
		{
			var p = pos.fileName.split('/').pop();
			ERROR += ' [' + p + ':' + pos.lineNumber + ']';	
		}else
		{
			// Throw Error -> Caught by CJOB-> call this.fail()
			ERROR += ' [' + CJob.getExStackThrownInfo() + ']';
		}
		
		status = CTaskStatus.fail;
	}//---------------------------------------------------;
	
	
	// Automatically called whenever completed or failed
	function kill()
	{
		if (killExtra != null) killExtra();
	}//---------------------------------------------------;
	
	// Quick information
	// --
	public function toString():String
	{
		return 'UID:$uid "$name"' + (desc == null?'':'($desc)') + ' SLOT:$SLOT , ASYNC:$async';
	}//---------------------------------------------------;
	
	
	// -- Quickly handle an APP success report
	public function handleCliReport(app:djNode.utils.CLIApp)
	{
		//app.events.once("close", function(a, b){
			//if (a){
				//complete();
			//}else{
				//fail(b);
			//}
		//});
		//
		//app.events.on("progress", function(p){
			//PROGRESS = p;
		//});
	}//---------------------------------------------------;
	
}// -